<h1 style="font-size:32px; text-align: center">Basic ASM/Hacking Zelda3 Tutorial</h1>

<h2 style="font-size: 30px;padding-left:80px;">
Table of Contents

</h2>
<h3 style="font-size:16px;padding-left:80px;font-weight:normal ">
<a href="#tools">1) Tools/Files Needed</a>
<br>
<a href="#asm">2) Basic ASM Explanation</a>
<br>
<a href="#menucode">3) Understanding Original Menu Code</a>

<br>
4) Snes Tiles/Tilemap Format
<br>
5) Making Custom Menu from B to Z
<br>
<br>
<br>




<div id="tools" style="font-size:20px;">
<b>Tools needed for Zelda3 hacking</b>
</div>
<a href="https://fusoya.eludevisibility.org/la/index.html">Lunar Address</a>  - to convert PC Address/Snes address
<br>
<a href="https://github.com/RPGHacker/asar/releases/tag/v1.81">Asar</a> - 65816 ASM Assembler
<br>
<a href="https://www.romhacking.net/utilities/119/">YY-CHR</a> - GFX Editor
<br>
<a href="https://fusoya.eludevisibility.org/zelda/index.html">ZCompress</a> or Lunar Compress - To Decompress/Compress GFX
<br>
<a href="https://www.smwcentral.net/?a=details&id=6523&p=section">SnesGFX</a> - to create tilemap/gfx easily
<br>
<a href="https://github.com/devinacker/bsnes-plus/releases/tag/v05">Bsnes+</a>
<br>
<a href="https://mh-nexus.de/en/hxd/">HXD</a> - Hex Editor
<br>
<a href="https://drive.google.com/file/d/0B51aWTNENbmSc1Y0eTlhM1Nncjg/view?resourcekey=0-XKqeWAmQabtHojs11jV5KQ">Disassembly + Infos</a>
<br>
<br>
<br>
<br>
<div id="asm" style="font-size:20px;">
    <b>Basic ASM Explanation</b>
</div>
<a href="https://wiki.superfamicom.org/65816-reference">65816 References / Wiki</a>
<br>
Here we will go throught the "basics" opcodes for the 65816, Load Values, Change RAM, Conditions, Jump/Goto nothing too fancy or complicated
<br>
I will use references to modern programming languages, but knowing a programming language is not really mandatory
<br>
On the snes there is a thing called <b>(A) Accumulator</b> and <b>(X,Y) Index Registers</b> to "load" and "store" values in ROM/RAM also the ZERO flag
<br>
They are also use to do comparisons for conditions, it might looks complicated at first but this is actually pretty easy here's some basic opcodes :
<br>
<br>
LDA - Is used to (LD) LOAD a value into (A), it can be used on a ROM Address, Ram Address, Constant value, this is probably the most used opcode
<br>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
<b>ASM :</b>
<br>
LDA #$08 ;Load a Constant value of #$08 in the (A)ccumulator
<br>
<b>Pseudo Modern Language :</b>
<br>
var A = 08; //Load value 08 into variable A
</blockquote>

<br><br>

STA - Is used to (ST) STORE (A) value into a RAM address
<br>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
<b>ASM :</b>
<br>
STA $1000 ; Store A value into Address $1000
<br>
<b>Pseudo Modern Language :</b>
<br>
var Address1000 = A; //set Address1000 variable on A value;
</blockquote>

<br><br>
CMP - (CoMPare) allow you to make a comparison between (A)ccumulator and an address or Constant
<br>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
<b>ASM :</b>
<br>
LDA #$08 ; Load Value #$08 into (A)ccumulator
<br>
CMP #$04 ; Compare #$04 with (A)ccumulator value IF Values are matching ZERO Flag is setted, otherwise it is unsetted like this example
<br>
<b>Pseudo Modern Language :</b>
<br>
var A = 08; //Set A on value 08
<br>
if (A == 04)
</blockquote>

<br><br>
BEQ - Branch if Equal, IF the ZERO flag is setted it will branch to the location next to it

<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
<b>ASM :</b>
<br>
LDA #$08 ; Load Value #$08 into (A)ccumulator<br>
CMP #$04 ; Compare #$04 with (A)ccumulator value IF Values are matching ZERO Flag is setted, otherwise it is unsetted like this example<br>
BEQ .matching<br>
... ; Not Matching<br>
.matching<br>
... ; Matching<br>

<br>
<b>Pseudo Modern Language :</b>
<br>
var A = 08; //Set A on value 08<br>
if (A == 04)<br>
{<br>
//matching<br>
}<br>
//not matching<br>
</blockquote>


<br><br>
BNE - Branch if Not Equal, IF the ZERO flag is UNset it will branch to the location next to it
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
<b>ASM :</b>
<br>
LDA #$08 ; Load Value #$08 into (A)ccumulator<br>
CMP #$04 ; Compare #$04 with (A)ccumulator value IF Values are matching ZERO Flag is setted, otherwise it is unsetted like this example<br>
BNE .notmatching<br>
... ; Matching<br>
.notmatching<br>
... ; Not Matching<br>

<br>
<b>Pseudo Modern Language :</b>
<br>
var A = 08; //Set A on value 08<br>
if (A != 04)<br>
{<br>
//not matching<br>
}<br>
//matching<br>
</blockquote>

<br><br>
JSL - Jump Subroutine Long allow you to go to a different portion of code in a different bank with the possibility of returning with RTL
<br><br>
JML - JuMp Long allow you to go to a different portion of code without possiblity of returning
<br><br>


<div id="menucode" style="font-size:20px;">
<b>Explaining the menu code from disassembly</b>
</div>
<br>
the menu code is located in the file <b>equipment.asm</b> open that file preferably with a code editor like VisualStudio Code, Notepad++ etc...<br>
get a pluggin for 65816 syntax i am using Visual Studio Code personally with the syntax highlight "65816 Assembly" by Josh Neta<br>
<br>
So lets start trying to understand the menu code this is really well commented so it should not be that hard to find codes<br>
we can scroll down a bit to the Local: section at line 34<br>
<pre>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd">
; *$6DD36-$6DD59 LOCAL
Local:
{
    ; Appears to be a simple debug frame counter (8-bit) for this submodule
    ; Of course, it loops back every 256 frames
    INC $0206
    
    LDA $0200
    
    JSL UseImplicitRegIndexedLocalJumpTable
    
    dw ClearTilemap       ; $DD5A = $6DD5A*
    dw Init               ; $DDAB = $6DDAB*
    dw BringMenuDown      ; $DE59 = $6DE59*
    dw ChooseNextMode     ; $DE6E = $6DE6E*
    dw NormalMenu         ; $DF15 = $6DF15*
    dw UpdateHUD          ; $DFA9 = $6DFA9*
    dw CloseMenu          ; $DFBA = $6DFBA*
    dw GotoBottleMenu     ; $DFFB = $6DFFB*
    dw InitBottleMenu     ; $E002 = $6E002*
    dw ExpandBottleMenu   ; $E08C = $6E08C*
    dw BottleMenu         ; $E0DF = $6E0DF*
    dw EraseBottleMenu    ; $E2FD = $6E2FD*
    dw RestoreNormalMenu  ; $E346 = $6E346*
}
</blockquote>
</pre>
<br>
This section is the Main function of the menu what is gonna happen at every step basically, so at first when you press start it will start on <b>ClearTilemap</b><br>
then <b>Init</b> and then <b>BringMenuDown</b>, once it's done scrolling <b>ChooseNextMode</b> then <b>NormalMenu</b> that is the Main loop for the menu code<br>
where you can move cursor around and pick items lets check the routine BringMenuDown first so Ctrl+F in your code editor search for "BringMenuDown:"
<br><br>

<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;white-space: pre-wrap">
; *$6DE59-$6DE6D JUMP LOCATION
BringMenuDown:
{
    REP #$20
    
    LDA $EA : SUB.w #$0008 : STA $EA : CMP.w #$FF18
    
    SEP #$20
    
    BNE .notDoneScrolling
    
    INC $0200

.notDoneScrolling

    RTS
}
</blockquote>
<br>
that is a very small routine, you should have a file called Zelda_3_RAM.log in the disassembly folder you can open that, that will help us understanding what is going on here<br>
so first of all we have a <b>REP #$20</b> that is basically telling the snes change the processor to read/write 16-bits (word) values from A instead of 8-bits (byte)<br>
then we have a <b>LDA $EA</b> so we are loading the value of the address $EA in A to know what is in $EA we will check in the Zelda_3_RAM.log file and search for $EA<br>

<b>$EA[0x02] - (NMI)</b><br>
BG3 vertical Scroll Register (BG3VOFS / $2112)<br>
<br>
so this is loading the scrolling value of BG3 (menu), in (A)ccumulator nothing more next we have<br>
<b>SUB</b> that is not an existing opcode it is a shortened opcode to combine 2 opcodes and should not be used real code here would be <b>SEC : SBC.w #$0008</b><br>
SEC will set the Carry you can ignore that for the moment, and SBC will Subtract a value from (A)ccumulator, so basically so far what that code is doing is <br>
Load BG3 Vertical Scrolling Value in A, Subtract #$0008 from it, next we have <b>STA $EA</b> that is storing back the scrolling value -8 in $EA because A got 08 removed from it<br>
<b>CMP.w #$FF18</b> here we are doing a CoMPare to see if scrolling value == #$FF18 which is -232 in decimal,<b>SEP #$20</b> we set back the processor mode to 8bits<br>
<b>BNE .notDoneScrolling</b> then we Branch if Not Equal -232 to a <b>RTS</b> which is a Return function that will end the menu code for this frame<br>
however when A is reaching -232 the <b>INC $0200</b> code will be ran before the RTS, which is INCrementing by one the value of an address<br>
$0200 is the position of the jumptable above so next frame we will be in the next subroutine which is <b>ChooseNextMode</b> 
<br>
<br>
<br>
so here a small exercice lets say we wanna change the scrolling speed of the menu i will show how to do it with a Hex Editor and with ASM<br>
if you check in the disassembly before the routine you usually have JUMP LOCATION that is the position where that code is located in the ROM<br>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;white-space: pre-wrap">
; *$6DE59-$6DE6D JUMP LOCATION
BringMenuDown:
</blockquote>

6DE59
so open up your zelda3 rom in a hex editor and make sure your rom is not headered you can use a header removal tool if you are not sure<br>
<a href="https://www.romhacking.net/utilities/593/">SNES ROM Utility</a> , All addresses in the Dissembly are PC Address and for Non-Headered ROM<br>
You can use the tool called Lunar Address to convert PC Address to Snes Address and vice-versa, make sure it has the box Include copier header UNCHECKED<br>
and set it on lorom 00:8000 (the first one) we'll come back to this in a moment so in the hex editor <br>

go to the Address <b>6DE59</b> by using CTRL+G in the hex editor, you should see something like this : <br>
<img src="hexeditor1.png" alt="hexeditor1">
what you are seeing is pretty much just the actual game code in HEX<br>
<pre>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
C2 20      REP #$20
A5 EA      LDA $EA
38         SEC
E9 08 00   SBC #$0008
85 EA      STA $EA
C9 18 FF   CMP #$FF18
E2 20      SEP #$20
D0 03      BNE .notDoneScrolling (03 means the branch is going 3 byte further)
EE 00 02   INC $0200
.notDoneScrolling
60         RTS
</blockquote>
</pre>

so lets try changing the SBC #$0008 into something else from a hex editor that is very simple all you need to do is edit the byte 08 to something else like 01<br>
becareful tho the code is comparing with a specific value what that means is if you are not decrementing the value by where -232 is not divisible it will infinitely scroll<br>
change that 08 in 01, save file with the hex editor, load your rom into your favorite emulator then press start to open your menu!<br>
if you did it right the menu should scroll down very slowly like that gif<br>
<img src="menuspeed.gif" alt="menuspeed">
<br>
see that's super simple !! now lets do it in ASM<br>
create a new file with your code editor call it <b>main.asm</b><br>
<pre>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
lorom ; This line is important to tell ASAR our ROM is in lorom mapping so it will write data to the right location in the ROM
org $0DDE59 ; This is where ASAR will know where to write new data in the ROM, The SNES Address is Different than PC Address explanation below
BringMenuDown:
{
REP #$20
LDA $EA
SEC
SBC #$00E8 ;Remove directly the 232 value
STA $EA
CMP #$FF18
SEP #$20
BNE .notDoneScrolling
INC $0200
.notDoneScrolling
RTS
}
</blockquote>
</pre>
<br>
First let explain the <b>org</b> function that's used by ASAR to know where to write code/data in the ROM it's followed by an address<br>
normally we would want that code written at the position 6DE59 since that's where we go in a hex editor to see that code but on the snes<br>
the addresses are not mapped the same basically to keep it simple in a PC BANK you have 65536 (0x10000) bytes, on snes only 32768 (0x8000) bytes<br>
so you need to convert that PC Address into Snes Address and we can use the tool Lunar Address for that with copier header checkbox unchecked and LOROM checked<br>
you enter the PC Address on left side and it give you the SNES Address on right side screen here :<br>
<img src="lunaraddress.png" alt="lunaraddress"><br>

IMPORTANT make sure your ROMs extension are .sfc, ASAR will not recognize properly .smc<br>
ok so now that we have our ASM file we need to build it into the rom so we need to run ASAR on it there are multiple easy way of doing it<br>
i personally put <b>Asar.exe</b>, <b>VanillaROM.sfc</b>, <b>main.asm</b> files in a same folder and use a .bat file with instructions like this<br>
<pre>
<blockquote style="border: 1px solid #888; padding: 4px; background-color: #ddd;">
copy "VanillaROM.sfc" "Patched.sfc"
asar.exe main.asm "Patched.sfc"
pause
</blockquote>
</pre>

save that file as <b>build.bat</b> then all you have to do to build new code into your ROM is run the build.bat file!<br>
if you are getting any error make sure all your files are in the same folder before running the .bat file the build.bat file also need to be in the same folder<br>
what that code will do is copy the VanillaROM.sfc file into a file named Patched.sfc then ASAR will patch the file Patched.sfc with main.asm code<br>
if you did it right you should have a file named <b>Patched.sfc</b> if you test that rom the menu should open instantly because we are removing whole value #$00E8<br>


<img src="menuspeed2.gif" alt="menuspeed2">

</h3>


<br>
<br>
<br>
<br>